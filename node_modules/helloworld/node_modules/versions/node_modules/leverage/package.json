{
  "name": "leverage",
  "version": "0.0.4",
  "description": "Leverage is a thin wrapper around the `redis` client that integrates your lua scripts as methods AND supports reliable and fault tolerant Pub/Sub on top of redis.",
  "main": "index.js",
  "scripts": {
    "test": "NODE_ENV=testing ./node_modules/.bin/mocha $(find test -name '*.test.js')"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/observing/leverage.git"
  },
  "keywords": [
    "redis",
    "pub",
    "sub",
    "pub/sub",
    "message",
    "queues",
    "lua",
    "scripting",
    "leverage"
  ],
  "author": {
    "name": "Arnout Kazemier",
    "email": "opensource@observe.it"
  },
  "license": "MIT",
  "devDependencies": {
    "chai": "1.6.x",
    "mocha": "1.9.x",
    "redis": "0.8.x",
    "pre-commit": "0.0.x"
  },
  "dependencies": {
    "underverse": "0.1.x"
  },
  "readme": "# leverage\n\nLeverage is an abstraction on top of the fabulous `redis` client for Node.js. It\nmakes it much easier to work with lua scripting in Redis as well as provide some\nsome missing features in Redis through the power of lua scripting.\n\n### Build status\n\n[![Build Status](https://travis-ci.org/observing/leverage.png)](https://travis-ci.org/observing/leverage)\n\n### Installation\n\nThe package should be installed through npm, which is installed by default when\nyou download node.js\n\n```\nnpm install leverage --save\n```\n\n### Usage\n\nTo introduce these methods, the module searches for a `lua` or `leverage` folder\nin the root of your application folder (which contains the `node_modules` folder\nthat has this module installed). It only accepts files with a `.lua` extension.\nThese files will be introduced as methods on the `Leverage` prototype. So if you\nhave a `hello.lua` file in the `leverage` folder we will automatically make a\n`leverage.hello()` method.\n\nBecause we are introducing the scripts as methods in the `Leverage.prototype`\nthere are a couple of names that blocked for usage or they would destroy the\nmodules internals. We've made sure that most of internals of this module are\nnamespaced user the `_` property but there are however a couple methods exposed\non the prototype:\n\n- `_` Our private internal namespace for logic and options.\n- `readyState` Which indicates if everything is loaded correctly.\n- `publish` For our improved Pub/Sub.\n- `subscribe` For our improved Pub/Sub.\n- `unsubscribe` Unsubscribe from our Pub/Sub channel.\n- `destroy` For closing all used/wrapped Redis connections.\n- [All EventEmitter methods][EE] and [it's private properties][EEprivate]\n\nAnd just to be save, don't use methods that are prefixed with an underscore\nwhich will just protect you possible private node internals. Other then these\nproperties and methods your save to anything you want as we will just remove all\nforbidden chars, numbers from your script name and transform it to lowercase.\n\n[EE]: http://nodejs.org/api/events.html#events_class_events_eventemitter\n[EEprivate]: https://github.com/joyent/node/blob/master/lib/events.js#L26-L37\n\nTo initialize the module you need to provide it with at least one active Redis\nconnection:\n\n```js\nvar Leverage = require('leverage')\n  , redis = require('redis').createClient();\n\nvar leverage = new Leverage(redis, { optional options });\n```\n\nIf you want to leverage the improved Pub/Sub capabilities you should supply 2\ndifferent clients. 1 connection will be used to publish the messages and execute\nthe commands while the other connection will be used to subscribe and there for\nblock the connection for writing.\n\n```js\nvar Leverage = require('leverage')\n  , pub = require('redis').createClient()\n  , sub = require('redis').createClient();\n\nvar leverage = new Leverage(pub, sub, { optional options });\n```\n\nIt might be possible that you want to add scripts from a different folder then\nour pre-defined folder locations. We've added a `Leverage.introduce` which you\ncan use to add scripts. The scripts that are added should be added to the\n`Leverage.scripts` array and you should add the scripts **BEFORE** you construct\na new Leverage instance.\n\n```js\nvar Leverage = require('leverage');\n\n//\n// Give the method the path of your lua files and the object or in our case the\n// prototype where you want to introduce the methods.\n//\nvar scripts = Leverage.introduce('/path/to/your/custom/directory', Leverage.prototype);\n\n//\n// IMPORTANT: Add the returned array of added scripts to our Leverage.scipts as\n// are checked during the bootstapping of the Leverage instance.\n//\nLeverage.scripts = Leverage.scripts.concat(scripts);\n```\n\nFYI: The `Leverage.introduce` methods returns an array with following data\nstructure:\n\n```\n{\n  name: 'hello',\n  args: {\n    KEYS: 2,\n    ARGV: 2\n  },\n  path: '/usr/wtf/path/to/file/hello.lua',\n  code: 'local foo = KEYS[0]\\nlocal bar = KEYS[1] .. etc ..'\n}\n```\n\nWe we attempt to load in the lua scripts in to the Redis server we attempt to\nparse the script to automatically detect how many keys that should be send to\nthe server. If your code isn't to magical it should just parse it correctly and\nset the amount of KEYS and ARGV's of your script. There might be edge cases\nwhere you are iterating over the keys and args or we just fail to correctly\nparse your lua code because you a frigging lua wizard. For these edge cases you\ncan supply every generated method with a number. This number should represent\nthe amount of KEYS you are sending to your scripts.\n\n```js\nleverage.customscript(2, 'KEY1', 'KEY2', 'ARGS', 'ARGS', fn);\n```\n\nBut doing this every time can be a bit wasteful that's why you can also just\ntell us once and the module will memorize it for you so all other calls will\njust use the same amount of keys.\n\n```js\nleverage.customscript(2);\nleverage.otherscript(10);\nleverage.anotherscript(3);\n\n//\n// You can now call the scripts without the needed key amount argument.\n//\nleverage.customscript('KEY1', 'KEY2', 'ARGS', 'ARGS', fn);\n```\n\n#### Options\n\nThe following options are available, most of these apply to the improved Pub/Sub\nsystem.\n\n<dl>\n  <dt>namespace</dt>\n  <dd>\n    <p>\n      The namespace is used to prefix all keys that are set by this module\n      inside of your redis installation. This way you can prevent conflicts from\n      happening. It defaults to <code>leverage</code>\n    </p>\n  </dd>\n\n  <dt>SHA1<dt>\n  <dd>\n    <p>\n      SHA1 can be provided a preconfigured object that contains references to\n      all method -> SHA1 mappings. Only change this if you know what the fuck\n      you are doing. If this is not set we will just check your redis server to\n      find out of the script has been loaded in the internal cache.\n    </p>\n  </dd>\n\n  <dt>backlog</dt>\n  <dd>\n    <p>\n      How many messages can we store for the pub/sub connection relaiblity if\n      you are sending a lot of message per second you might want to set this to\n      a higher number then you would with lower rate messages. It defaults to\n      <code>10000</code>. The messages are stored using FIFO so if you are\n      storing to much messages it will automatically override older keys.\n    </p>\n  </dd>\n\n  <dt>expire</dt>\n  <dd>\n    <p>\n      To make sure that we don't leave to much crap in your database all stored\n      messages are provided with a expire value. So the messages can be killed\n      in 2 ways, either by an overflow of the backlog or by an expired key. The\n      default expiree is <code>1000</code>.\n    </p>\n  </dd>\n</dl>\n\n### Pub/Sub\n\nOur Pub/Sub wrapper provides a reliable Pub/Sub implementation on top of the\nfire and forget Pub/Sub implementation of redis. This is done by leveraging (ooh\nsee what I did there ;)) lua scripts.\n\n#### leverage.publish(channel, message, [callback])\n\nPublishing is as easy as:\n\n```js\nleverage.publish(channel, message, function (err, id) {\n  // optional error and the unique id of the message\n});\n```\n\nThe callback is optional, but I would advice you to use it so you know which id\nyour message has and if it was send without any issues. When you publish a\nmessage the following events take place:\n\n1. We increase a unique counter for the given channel so we have a unique `id`\n   for the message.\n2. Create a `packet` which contains the message and the id of the message.\n3. The package is stored as simple key/value where they key contains the channel\n   and the unique `id`.\n4. The packet is published to the channel.\n\n#### leverage.subscribe(channel, { options })\n\nThe subscription command has a bit of different syntax then you are used to. It\naccepts a second argument which can be used to configure the reliablity of the\nPub/Sub channel:\n\n```js\nleverage.subscribe('channel', { options });\n```\n\nThe subscription command can be configured with:\n\n<dl>\n  <dt>ordered<dt>\n  <dd>\n    <p>\n      Force ordered delivery of messages. If a message is dropped all received\n      messages will be queued until the missing message is retrieved again and\n      then the queue is flushed again. Defaults to <code>false</code>.\n    </p>\n  </dd>\n\n  <dt>bailout</dt>\n  <dd>\n    <p>\n      When we received an error while processing and receiving messages we can\n      stop the subscription as we can no longer guarantee so the sensible thing\n      to do would be giving up and unsubscribing from the channel and stop with\n      all processing. Defaults to <code>true</code>.\n    </p>\n  </dd>\n\n  <dt>replay</dt>\n  <dd>\n    <p>\n      How many events should we retrieve when we join the channel for the first\n      time as it might happen that we've received a message right before we\n      subscribed. Defaults to <code>0</code>.\n    </p>\n  </dd>\n</dl>\n\nWhen you join a channel the follwing events take place:\n\n1. The current id is retrieved.\n2. Older messages are retrieved if needed\n3. A packet is send back which contains all fetched messages and the current id.\n\nOnce you are subscribed to a channel the messages will be emitted on the\n`leverage` instance. There are a couple of different events emitted:\n\n- `<channel>::message` A message has been received.\n- `<channel>::bailout` We've received an error and are bailing out.\n- `<channel>::error` The channel received an error.\n- `<channel>::online` The channel has started processing messages.\n- `<channel>::unsubscribe` The channel has been unsubscribed.\n\n`<channel>` is the name of the channel that you've subscribed to.\n\n```js\nleverage.subscribe('foo').on('foo::message', function onmessage(message, id) {\n  console.log('Received the following message: ', message);\n  console.log('The message had the following id: ', id);\n});\n\nleverage.on('foo::bailout', function bailout(e) {\n  console.log('The following error caused the bailout', e);\n});\n\nleverage.on('foo::error', function error(e) {\n  console.log('We received an error', e);\n  console.log('This was emitted before a bailout, if bailouts were enabled');\n});\n```\n\n#### leverage.unsubscribe(channel, [callback])\n\nUnsubscribe from the channel, nothing special here.\n\n```js\nleverage.unsubscribe('foo', function unsubscribed(err) {\n ..\n});\n```\n\nThis also triggers the `<channel>::unsubscribe` event.\n\n#### Note:\n\nAll these operations happen atomicly and are namespaced under the namespace that\nyou configured `Leverage` with. So you cannot (and should not) publish to\nchannels that are not wrapper by Leverage.\n\n## LICENSE\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/observing/leverage/issues"
  },
  "homepage": "https://github.com/observing/leverage",
  "_id": "leverage@0.0.4",
  "_from": "leverage@0.0.x"
}
